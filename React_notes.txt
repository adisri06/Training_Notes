Fundamentals of libraries : React is a library 
What is library ? 
1. Library is a collection of prewritten code which provides us with reusable functions and code base,
With this reusable code base we can target a specific tasks or functionalities .

Framework : Angular is a framework ,
What is framework ? 
1. A framework is a comprehensive software development platform that provides the 
foundation and structure for building entire applications. 
Unlike libraries that offer specific functionalities, 
frameworks impose a particular architecture and provide tools, libraries, and 
guidelines to streamline the development process. Frameworks address broader concerns, 
including handling user requests, managing data flow, and structuring the application's overall architecture.
 Some popular examples of JavaScript frameworks include AngularJS, Ember JS, Svelte, and Vue.js.

React Basics:

	•	Overview:
	•	Developed by: Meta (formerly Facebook)
	•	Purpose: To build dynamic, interactive user interfaces for web applications
	•	Type: Open-source JavaScript library
	•	Core Features:
	1.	Component-Based Architecture:
	•	Modular design with reusable components
	•	Components represent specific UI elements (e.g., header, sidebar, footer)
	•	Encapsulation of UI functionality in individual files for reusability
	2.	Declarative Syntax:
	•	Developers specify what the UI should do, rather than how it should operate
	•	Automatically updates UI based on state or data changes
	3.	Virtual DOM:
	•	React maintains a virtual copy of the DOM
	•	Efficiently updates only the necessary parts of the real DOM, boosting performance
	4.	One-Way Data Binding:
	•	Unidirectional data flow from parent to child components
	•	Simplifies data management, reducing bugs due to state inconsistencies
	5.	JavaScript XML (JSX):
	•	JavaScript extension that enables HTML-like syntax within JavaScript
	•	Simplifies creation and visualization of UI components
	6.	Hooks:
	•	Introduced in React 16.8
	•	Facilitates state and lifecycle management within functional components
	•	Simplifies logic, promotes code reuse, and eases management of stateful behavior
	7. Resolves problems of cross browser issues .
	8. React native : Similar to react and can help to create cross platform application.

Creating a react project  (Either one of them )
npx create-react-app my-react-app
npm create vite@latest my-vite-app
npm install 
npm run dev

Difference between both : 
Here’s a quick comparison between Vite and Create React App (CRA) for interview prep:

Vite vs. Create React App (CRA)

1. Build Speed

	•	Vite: Faster builds, near-instant dev server, fast HMR (Hot Module Replacement).
	•	CRA: Slower initial build and reload times, especially in large projects.
	Unlike CRA, which uses Webpack, Vite uses Rollup for bundling, resulting in faster build times and 
	improved performance, especially for larger projects.

Vite also supports various modern JavaScript features out of the box, such as TypeScript, JSX, and CSS preprocessors, without additional configuration.

2. Configuration

	•	Vite: Flexible, easy to customize with plugins, no “eject” needed.
	•	CRA: Zero-config but restrictive; must “eject” to access deeper configs.

3. Developer Experience

	•	Vite: Smooth, fast HMR, supports modern JavaScript features.
	•	CRA: Reliable but can be slow on reloads in larger projects.

4. Ecosystem

	•	Vite: Growing rapidly, multi-framework support (React, Vue, Svelte).
	•	CRA: Established, extensive community, React-focused.

5. Best For

	•	Vite: Larger or modern React projects needing speed and scalability.
	•	CRA: Small/medium projects, beginners needing simplicity.

Summary:

	•	Vite is better for performance, flexibility, and modern development.
	•	CRA is good for straightforward, smaller apps without heavy customization needs.

Folder Structure Notes

	•	public directory
	•	Contains static assets (e.g., HTML files, images, fonts).
	•	index.html: Entry point for the React app.
	•	src directory
	•	Holds the source code for the React app.
Key Files in src:
	•	main.jsx: Entry point file that renders the root component into the HTML in the public directory.
	•	App.jsx: Root component containing the main UI logic and other components.
	•	App.css: Styles specific to App.jsx.
	•	index.css: Global styles for the application.
	•	Other Files
	•	package.json: Holds project metadata, dependencies, and scripts for running, building, and testing the app.

This structure provides a boilerplate setup for React projects, with organized folders for assets, core app files, and configuration.

ES6 : EcmaScript 6

Introduction to ES6 (ECMAScript 6)

	1.	ECMAScript Overview
	•	ECMAScript (ES) is a standard for JavaScript created by the ECMA standards organization.
	•	ES6, released in 2015, introduced major updates.
	•	Newer versions of ES are named by release year; the latest is ECMAScript 2020.
	•	“ES.Next” refers to the upcoming ECMAScript version.
	2.	Key ES6 Features
	•	let and const: Alternatives to var with restricted scope.
	•	let is block-scoped, restricting variable usage to the block it was defined in.
	•	const defines constants whose values cannot be reassigned.
	•	Arrow Functions: A shorter syntax for writing functions, offering cleaner, concise code.
	•	Arrow functions can omit curly braces and the return keyword for single-line expressions.
	•	Commonly used in callbacks.
	•	Promises: A way to handle asynchronous operations.
	•	Promise states: pending, fulfilled, and rejected.
	•	resolve and reject are parameters used to handle the completion status.
	•	Class: Introduced object-oriented programming features.
	•	Built on JavaScript prototypes, enabling inheritance and encapsulation.
	•	Classes use a constructor for initializing new objects.
	•	this keyword refers to the current instance, and new creates new instances.
	•	Inheritance: Classes can inherit properties/methods from other classes (superclass/subclass).
	•	super calls the superclass constructor in subclasses.
	3.	Usage in JavaScript
	•	ES6 features are compatible with frameworks like React.
	•	Enhanced syntax and tools in ES6 facilitate code organization, readability, and scalability.

	JSX Overview

	1.	Definition
	•	JSX stands for JavaScript Syntax Extension, also called JavaScript XML.
	•	It combines HTML-like syntax with JavaScript expressions, making UI building more intuitive.
	2.	Syntax and Usage
	•	JSX syntax resembles XML/HTML, with elements in angle brackets (< >), showing UI structure.
	•	JSX is used to create React elements, rendered into the DOM by React.
	•	Browsers don’t recognize JSX directly; it must be compiled with Babel to convert it to standard JavaScript objects.
	3.	Compilation with Babel
	•	Babel translates JSX into JavaScript, making it readable for JavaScript engines.
	•	The create-react-app command can handle JSX compilation automatically.
	4.	Advantages of JSX
	•	Readability: Easier to understand, especially for those familiar with HTML.
	•	Error Detection: Compilation catches errors early.
	•	Code Simplification: Keeps code elegant and organized with inline styling options.
	•	Performance: Optimized for faster execution during translation.
	•	Security: Automatically sanitizes output to prevent embedded scripts from executing.
	5.	JSX vs. JavaScript Function Calls
	•	JSX syntax is cleaner, closer to HTML, and easier to read compared to equivalent JavaScript function calls.
	•	Regular JavaScript function calls for the same purpose are harder to read and maintain.
	6.	Summary
	•	JSX reads like HTML but allows JavaScript expressions within it.
	•	Benefits of JSX include enhanced readability, error handling, performance optimization, and security.

	Notes: Introduction to Components in React

Overview of React Components:

	1.	Definition: Modular chunks of code used to build React applications.
	2.	Purpose: Simplify complex UIs by dividing them into manageable, reusable pieces.
	3.	Rendering: Components are merged to form the main UI the user sees.

Features of React Components:

	•	Break down UI into separate, independent elements.
	•	Accept optional input and return a React object for rendering.
	•	Can manage UI updates through “state changes.”

Component Structure in React:

	1.	Properties (Props):
	•	Store and pass data from parent to child components.
	2.	Events:
	•	Manage the DOM based on user interaction.
	3.	States:
	•	Track and manage UI updates within the component.

Types of React Components:

	1.	Functional Components:
	•	Defined as JavaScript functions, taking arguments and returning JSX.
	•	Initially stateless but now can manage state using hooks (introduced in React 16.8).
	•	Preferred for simplicity and ease of testing.
	•	Example:

function DemoComponent() {
  return <h1>Welcome Message</h1>;
}


	2.	Class Components:
	•	Built using ES6 classes, allowing data sharing between class components.
	•	Utilize React-specific functions: state, props, and lifecycle methods.
	•	Complex and less preferred post-React 16.8 due to the availability of hooks.
	3.	Higher-Order Components (HOC):
	•	Allow reuse of component logic by taking a component as input and returning a new component with additional features.

Key Points Recap:

	•	React components modularize the UI into reusable parts, managing events, rendering, and state.
	•	Three component types: functional, class, and higher-order

Working with Function Components, Props, and Event Handling in React

Key Concepts:

	•	Props in Function Components:
	•	Properties in function components are called props.
	•	Purpose: Props pass data from a parent component to its child, enabling data flow and customization of child components.
	•	Nature: Props are immutable—data within them is read-only in the child component and cannot be modified.
	•	Basic Usage of Props:
	•	Props work similarly to objects, holding attributes for a component.
	•	Example:
	•	In a component App, data is passed as a prop (e.g., name="John") to the child component EmployeeData.
	•	In EmployeeData, props are accessed using props.name.
	•	Props can also be dynamically passed with curly braces {} for variables (e.g., employee_id).
	•	Default Props:
	•	Default values can be defined for props, providing fallback values if the parent component does not pass them.
	•	Example: EmployeeData has a default value of "Human Resources" for the dept_name prop if not explicitly provided.
	•	Principles of Props:
	•	Reusability: Props allow variations of the same component without duplicating code.
	•	Unidirectional Data Flow: Data flows in one direction, making the app structure predictable and error tracing easier.
	•	Customization: Components can adapt their behavior and appearance based on prop values.
	•	Composition: Props help in composing complex UIs from simpler components through organized data flow and interaction.

Event Handling with Props:

	•	Example with useState Hook and Event:
	•	Props can be used alongside event handling to control component behavior dynamically.
	•	useState Hook: Manages the showIncrease state to track whether salary increase information should display.
	•	onClick Event:
	•	Triggers an arrow function to toggle showIncrease state.
	•	Conditional rendering is achieved using &&, so when showIncrease is true, the salary increase value is shown.
	•	UI Changes on Event:
	•	When the user clicks a button, it updates the showIncrease state and displays additional information accordingly.

Summary Points:

	•	Props store component attributes and enable data flow from parent to child.
	•	Props principles include reusability, unidirectional data flow, customization, and composition.
	•	Using useState with event handlers enables responsive and interactive UI updates.

React Component Composition

	•	Purpose:
	•	Component composition combines small, reusable components to build complex UIs, enhancing modularity and maintainability.
	•	Principles of Component Composition:
	•	Abstraction: Encapsulate UI features into reusable components, breaking down complex UIs into manageable chunks.
	•	Reusability: Avoid code duplication by reusing components across different parts of the application.
	•	Hierarchy: Arrange components in a parent-child structure for organized, modular design.
	•	Props and Children: Pass data from parent to child components; child components inherit data or other components via props.
	•	Higher-Order Components (HOCs): Functions that accept components as input or return enhanced components with added functionality (e.g., state or logic).
	•	Example: Blog Post for Novels:
	•	Individual Components:
	•	Title, Author, Type, Description: Each component encapsulates a specific feature and follows a consistent structure:
	•	Import React, define function, format content, and export the component.
	•	Higher-Order Component (NovelBlog):
	•	Combines individual components to create a full blog post structure.
	•	Imports and arranges components (Title, Author, Type, Description) with styling.
	•	Main Application Component:
	•	Imports and composes the NovelBlog component, supplying data for title, author, description, and type.
	•	Summary:
	•	Use component composition to combine smaller, reusable components for complex UIs.
	•	Key principles: abstraction, reusability, hierarchy, props and children, HOCs.

State Management in Functional Components (React)

Introduction to State Management

	•	State management controls data changes within a React component.
	•	Previously, React couldn’t manage state in function components until hooks were introduced.
	•	Now, function components handle local state via the useState hook, enabling reusable logic without altering the component hierarchy.

useState Hook Overview

	•	useState allows state management in functional components.
	•	Returns an array with:
	•	A state variable for the current state.
	•	A function to update this state variable.
	•	Syntax:

const [stateName, setStateName] = useState(initialState);

	•	stateName: holds the current state value.
	•	setStateName: function to update the stateName.

Example: State Management with useState

	1.	Basic Setup:
	•	Create a component StateManagement using useState for the name state.
	•	Initialize name to “John” and update to “John Doe” upon button click.
	2.	Rendering the Component:
	•	Displays an <h1> title and a paragraph with the current name state.
	•	Includes a button with an onClick event to trigger setName("John Doe"), updating the name.

Example: Toggle Component with useState

	1.	ToggleMessage Component:
	•	Manages visibility of a message using isVisible state.
	•	Toggle button changes visibility by setting isVisible to !isVisible.
	2.	Rendering Toggle:
	•	Shows button text as “Hide message” if isVisible is true; otherwise, “Show message.”
	•	Conditionally displays a message based on isVisible’s value.

Summary

	•	State management helps manage and reflect dynamic data within components.
	•	useState provides a clean way to handle state in functional components.
	•	Key uses include making components interactive and managing conditional rendering.

Function Component Lifecycle in React


	•	Functional components are the core of React UI development.
	•	Although lacking traditional lifecycle methods (as in class components), hooks (e.g., useState, useEffect) allow similar lifecycle management.

Lifecycle Phases of Functional Components

	1.	Mounting Phase
	•	React initializes and prepares the component for rendering.
	•	Key steps:
	•	Initialization: Function body runs, setting up the component structure.
	•	State Initialization: useState sets up state variables (e.g., count initialized to 0).
	•	Side Effects: useEffect with an empty dependency array runs side effects (e.g., data fetching, DOM manipulation) once after the initial render.
	•	Example: useEffect fetches data on mount from an API and sets it in the component’s state.
	2.	Updating Phase
	•	React re-invokes the function component when state or props change, allowing UI updates.
	•	React re-evaluates JSX to determine new UI.
	•	Example: In myComponent, count is incremented on button click, triggering a re-render with updated UI.
	3.	Unmounting Phase
	•	React cleans up resources (e.g., event listeners, timers) when the component is removed from the DOM.
	•	Example: useEffect sets up an interval timer; a cleanup function clears it on unmount to prevent memory leaks.
	4.	Error Handling Phase
	•	Errors during rendering or lifecycle methods in child components are caught by error boundaries.
	•	Error boundaries display fallback UI, isolating the error without affecting the rest of the application.

Summary

	•	React’s lifecycle for function components includes:
	•	Mounting: Sets initial state, runs side effects.
	•	Updating: Handles state/prop changes, updates UI.
	•	Unmounting: Cleans up resources to prevent memory leaks.
	•	Error Handling: Uses error boundaries for graceful error management.

Testing React Components

	1.	Purpose of Testing
	•	Testing reviews code line-by-line to verify correct execution.
	•	Ensures application runs smoothly without errors.
	•	Advantages:
	•	Prevents regression (reoccurrence of bugs).
	•	Allows developers to focus on current tasks.
	•	Enables modular application construction.
	•	Reduces the need for manual verification.
	•	Disadvantages:
	•	Involves writing, debugging, and maintaining additional code.
	•	Non-critical test failures might impact CI processes.

	2.	Types of Testing in React
	•	Unit Testing:
	•	Tests isolated parts/components.
	•	Uses shallow rendering.
	•	Example: Rendering a component with default properties.
	•	End-to-End Testing:
	•	Tests entire application flows in a simulated browser environment.
	•	No UI is required during tests.
	•	Example: Testing an authentication flow.

	3.	Testing Workflow (Arrange-Act-Assert)
	•	Arrange: Set up component properties.
	•	Act: Render the component, trigger user actions.
	•	Assert: Verify outcomes and side effects on the component.

	4.	Considerations When Choosing Testing Tools
	•	Speed vs. Environment: Some tools prioritize speed but lack precise browser behavior, while others use real browser environments with slower feedback loops.
	•	Mocking: Important to decide which parts to mock in unit vs. integration tests.

	5.	Testing Libraries in the React Ecosystem
	•	Mocha, Chai, Sinon: Used with Node.js applications for tests.
	•	Mocha: Test runner.
	•	Chai: Assertion library.
	•	Sinon: Provides mocks, stubs, and spies.
	•	Jest: Comprehensive testing library by Facebook.
	•	Test runner, assertion library, mocks, and spies.
	•	Features:
	•	jsdom: Access DOM for component testing.
	•	Snapshot Testing: Verifies component rendering results.
	•	CLI for test execution.
	•	React Testing Library:
	•	Utility functions built on react-dom and react-dom/test-utils.
	•	Encourages tests that align with end-user interactions.
	•	Replaces Enzyme for testing React components.
	•	Accessible querying for DOM elements, facilitating label- and text-based querying.
	•	Encourages accessibility and emulates end-user component usage.
	
	6.	Testing Best Practices
	•	Render components virtually using render() from React Testing Library.
	•	Access rendered HTML through screen for assertions.
	•	Aim for tests that emulate actual user interactions to increase confidence.

Arrays in React:

1. Defining Arrays in React

	•	Concept: Arrays are a fundamental JavaScript data structure for storing multiple values. In React, they are essential for managing lists of data dynamically.
	•	Example:

const seasons = ['autumn', 'spring', 'summer', 'winter'];

2. Using Arrays in Component State

	•	Concept: Arrays can be stored in React’s component state using the useState hook, making it easy to add or remove items dynamically.
	•	Example:

const [items, setItems] = useState(['autumn', 'spring', 'summer', 'winter']);

3. Traversing Arrays in React Components

	•	Methods:
	•	map: Returns a new array with JSX elements for each item.
	•	forEach: Executes a function on each item without returning a new array.
	•	for...of: Iterates directly over array elements.
	•	Example:

items.map((season, index) => <li key={index}>{season}</li>);

4. Rendering Lists with JSX and Array Methods

	•	Concept: Arrays are often used to render lists in React. Use map to create JSX elements for each item in an array.
	•	Example:

const SeasonList = () => (
  <div>
    <h1>Season Names</h1>
    <ul>
      {items.map((season, index) => (
        <li key={index}>{season}</li>
      ))}
    </ul>
  </div>
);

5. Adding and Removing Items from Arrays

	•	Concept: Use setState to modify arrays in state, such as adding items with push and removing with splice.
	•	Example:

// Adding items
const addItem = () => setItems([...items, newItem]);

// Removing items by index
const removeItem = (index) => {
  const newItems = [...items];
  newItems.splice(index, 1);
  setItems(newItems);
};

6. Conditional Rendering Based on Array Content

	•	Concept: Use conditional rendering in React to display different content based on the array’s state.
	•	Example:

{items.length > 0 ? (
  <ul>
    {items.map((item, index) => (
      <li key={index}>{item}</li>
    ))}
  </ul>
) : (
  <p>No items available</p>
)}


7. Key Takeaways

	•	Common Methods: map, forEach, push, and splice.
	•	State & Dynamic Updates: useState for managing lists dynamically within React components.
	•	Conditional Rendering: Render content conditionally based on the array’s length or content.


Virtual DOM in React

	1.	DOM Overview:
	•	Definition: The Document Object Model (DOM) represents an HTML structure as a tree-like structure.
	•	Components: Nodes (element, text, attribute), elements (HTML building blocks), attributes (element properties/styles), and events (JavaScript response triggers).
	•	Purpose: Allows dynamic manipulation of document content, structure, and style.
	2.	Virtual DOM Overview:
	•	Definition: A memory-based abstraction of the actual DOM.
	•	Purpose: Optimizes web application performance, synchronizing with the real DOM via React’s reconciliation.
	3.	How Virtual DOM Works:
	•	Initial Render: A virtual DOM model is created when a React component first renders.
	•	Updating Process: On state or prop changes, React:
	•	Creates a new virtual DOM.
	•	Uses a diffing algorithm to identify minimal updates needed.
	•	Applies updates to the real DOM in a batched and efficient way.
	4.	Advantages of Virtual DOM:
	•	Performance: Reduces frequency of direct DOM changes, resulting in faster applications.
	•	Declarative Development: Simplifies code with declarative syntax, handling DOM manipulation behind the scenes.
	•	Cross-Platform Compatibility: Works efficiently on web browsers and mobile devices.
	•	State Management: Works with state changes, enabling optimized updates and re-renders.
	•	Debugging and Testing: Simplifies testing and debugging using the virtual DOM view.
	5.	Comparison: Normal DOM vs. Virtual DOM:
	•	Normal DOM: Directly interacts with the browser’s rendering engine, re-rendering with each change.
	•	Virtual DOM: Exists in memory, updates are batched, reducing transitions and improving efficiency.
	•	Efficiency: Virtual DOM only applies necessary updates, reducing reflows and repaints.
	6.	Example in React:
	•	Components: App (parent), FirstChild, and SecondChild.
	•	Behavior: Updating one item in FirstChild does not trigger a re-render of App or SecondChild.
	•	Outcome: Demonstrates efficient re-rendering with React’s virtual DOM, updating only the affected component.
	7.	Key Takeaway:
	•	Virtual DOM in React enhances performance by updating only necessary parts of the DOM, essential in scenarios where selective component updating is beneficial.

Cheat Sheet 
1. Function Component with function keyword
Function component starts with function keyword along with name of the component and includes html tags within return. It also exports component name by default
import React from 'react'

function Extra() {
  return (
    <>
    <p>This is paragraph</p>
    </>
  )
}

export default Extra

Function Component with arrow function
Function component starts with variable type along with name of the component and includes html tags within return. It also exports component name by default
import React from 'react'
const Extra = () => {
  return (
    <div>Extra</div>
  )
}
export default Extra

Props in function component
Props can be sent from parent component as attribute along with child component
import React from 'react'
import ChildComponent from './ChildComponent'
function ParentComponent () {
    let title='Project Manager';
    return (
    <>
    <ChildComponent title={title}/>
    </>
  )
}
export default ParentComponent

Access Props within child function component
Props can be accessed easily within the child function component using props.variable_name
import React from 'react'

const ChildComponent = (props) => {
  return (
    <>
    <p>The title is {props.title}</p>
    </>
  )
}

export default ChildComponent

Event handling in class component
Events such as click event can be performed by calling function which is declared before return of function component
import React from 'react'
const Extra = (props) => {
    function show(){
        console.log('Show function');
    }
  return (
    <>
    <p>The title is {props.title}</p>
    <button onClick={()=>show()}>Click Here</button>
    </>
  )
}
export default Extra

State management in function component
State management can be done easily with useState() hook
import React, { useState } from 'react'

const StateManagement = () => {
    const[name,setName]=useState('John');
  return (
   <>
   <h1>State Management using useState</h1>
    <p>The name is {name}</p>
   </>
  )
}
export default StateManagement

Stateful Array
Array can be declared using useState	
const [todos, setTodos] = useState(['Learn React', 'Build Project']);

Array map() method
The map() method is commonly used to iterate over each element of an array and return a new array of React elements
const items = ['Apple', 'Banana', 'Orange'];
const itemList = items.map((item, index) => <li key={index}>{item}</li>);
return <ul>{itemList}</ul>;

Rendering a List of Items
You can render a list of items by mapping over an array and returning a JSX element for each item
import React from 'react';
function ArrayComponent() {
  const items = ['Autumn', 'Spring', 'Summer','Winter'];
  return (
    <div>
      <h1> Seasons Names</h1>
      <ul>
        {items.map((item, index) => (
          <li key={index}>{item}</li>
        ))}
  </ul>
    </div>
  );
}
export default ArrayComponent;

Conditional rendering using ternary operator
You can conditionally render components based on the content of an array
import React, { useState } from 'react';
function ArrayComponent() {
    const [items, setItems] = useState(['React JS','Vue JS','Angular JS','Vanilla JS']);
  return (
    <div>
      <h1>Front End Languages</h1>
      {items.length > 0 ? (
        <ul>
          {items.map((item, index) => (
            <li key={index}>{item}</li>
          ))}
        </ul>
      ) : (
        <p>No Front End language is available</p>
      )}
    </div>
  );
}
export default ArrayComponent;

| Term                        | Description                                                                                                                |
|-----------------------------|----------------------------------------------------------------------------------------------------------------------------|
| Document object model (DOM) | An interface for web pages and documents used to represent an HTML structure as a tree-like structure.                  |
| Higher-order component 	  | A function that allows you to add components' features, such as state management or logic, without modifying its implementation. |
| Hook                  	  | A function that enables you to reuse code logic across components without changing component hierarchy or introducing unnecessary nesting. |
| Initialization              | A step in which React runs the function body of the functional component, setting up the initial structure and behavior of the component. |
| Props Default               | Is default value for props using defaultProps. This ensures that if a prop is not provided, the component will still render with the default value, enhancing predictability and robustness in component behavior. |
| Properties (props)          | A fundamental concept in React for passing data from parent to child components. They enable communication and customization between different parts of a React application. |
| Side effects                | A step that includes data fetching, subscriptions, or DOM manipulation using the 'useEffect' hook with an empty dependency array. |
| Updating phase              | A functional component lifecycle phase in which React responds to changes in the component's state or props by re-invoking the function body of the component. |
| Unmounting phase            | A functional component lifecycle phase in which React executes cleanup operations when removing a component from the DOM. |
| Virtual DOM                 | An abstraction of the actual DOM implemented in memory and is kept in sync with the real DOM by React's reconciliation process. |

React Hooks (Extended with useEffect and Custom Hooks)

	1.	Purpose of Hooks:
	•	Introduced in React v16.8 to simplify state management and lifecycle handling in functional components, eliminating the need for class components.
	•	Hooks make functional components as powerful as class components, reducing code complexity.

	2.	Advantages of Hooks:
	•	Readability & Maintainability: Improved readability and smaller, manageable code chunks.
	•	Optimized UI Behaviors: Enable complex behaviors in UI with simplified code.
	•	Performance Boost: Enhances component performance.
	•	Event Handling: Simplifies event handling and logic without needing classes.
	•	Code Reusability: Custom hooks allow reuse of logic across multiple components.

	3.	Best Practices for Using Hooks:
	•	Hooks are exclusive to functional components.
	•	Must be called at the top level of a component, not within loops, conditions, or nested functions.
	•	Environment Requirements: Requires Node.js v6+ and NPM v5.2+; create-react-app is recommended for setup.

	4.	Commonly Used Standard Hooks:
	•	useState: Manages local component state, allowing state updates and reactivity.
	•	useEffect: Handles side effects like data fetching, subscriptions, and document manipulation.
	•	useContext: Provides access to context values across a React component tree.
	•	useReducer: Simplifies state management similar to Redux, with dispatching actions and maintaining state.

	5.	useEffect and Side Effects:
	•	Definition: useEffect is a React hook that lets functional components perform side effects, such as fetching data, updating the DOM, or setting up event listeners.
	•	Side Effects: Refers to actions executed after component load, such as API calls, event subscriptions, or timers.
	•	Example: A component with useEffect can fetch a list of food items from an API when the component mounts, update the state, and render the data dynamically.
	
	6.	useEffect Dependencies:
	•	Dependency Array: Controls when useEffect runs.
	•	Empty Array: Runs only once, on the first component load (good for initial setup like fetching data).
	•	Specific Dependencies: Runs when any listed dependency changes, triggering re-renders based on these changes.
	•	No Array: Runs on every render, including initial load and each subsequent re-render, which can lead to performance issues in some cases.
	
	7.	Custom Hooks:
	•	Definition: Custom hooks are reusable functions prefixed with ‘use’ that abstract complex logic to be reused across multiple components.
	•	Example: Toggle Button: A custom hook (useToggle) is used to manage a toggle state (true/false) in multiple components, providing a simple way to create toggle functionality.
	•	Reusability: Custom hooks make it easy to implement repetitive logic consistently across an app.
	
	8.	Example of useState and useEffect Combined:
	•	useState to initialize and manage state (e.g., foods array).
	•	useEffect to perform an asynchronous API fetch, parse the response, update the state, and display the data dynamically in the component.
	
	9.	Key Takeaway:
	•	Hooks provide functional components with class component capabilities, enabling concise, reusable, and efficient code in React applications. Use useEffect for side effects, dependencies to control re-renders, and custom hooks for shared logic.

Notes on Connecting React to External Services

	•	External Services
External services are programs, platforms, or infrastructures that allow your application to interact with other applications over a network. These services are usually hosted outside your application’s environment and provide features or tools your application may need.
	•	APIs (Application Programming Interfaces)
APIs allow your application to exchange data with external services. Third-party services typically provide APIs that let you retrieve data, perform operations, or add features to your application.
	•	Fetching Data Using API
	•	Fetch API
	•	The fetch() method is used to send HTTP requests to an external service.
	•	Example Process:
	1.	API URL: Store the URL of the API in a constant variable.
	2.	Fetching Data: Use fetch() with the URL to send a GET request to the external service.
	3.	Handling Response:
	•	Use .then() to handle the successful response.
	•	Call response.json() to parse the response into JSON.
	•	Chain another .then() to handle the parsed JSON data and perform actions like logging it to the console.
	4.	Error Handling: Use .catch() to handle errors during the fetch process. Log the error to the console for debugging.
Code Example:

const apiUrl = "https://jsonplaceholder.typicode.com/posts";
fetch(apiUrl)
  .then(response => response.json()) // Parse response body as JSON
  .then(data => console.log(data))    // Handle parsed data
  .catch(error => console.error("Error fetching data:", error)); // Handle errors


	•	Axios
Axios is a popular JavaScript library for handling HTTP requests. It simplifies the process and provides features like automatic JSON parsing.
	•	Installing Axios: npm install axios
	•	Usage: Import Axios and use the .get() method to make GET requests.
	•	Features:
	•	Automatically parses the response into JSON.
	•	Provides a .then() method to handle the successful response and access the data via response.data.
	•	Provides a .catch() method for error handling.
Code Example:

import axios from 'axios';
const apiUrl = "https://jsonplaceholder.typicode.com/posts";
axios.get(apiUrl)
  .then(response => {
    console.log(response.data); // Access response data directly
  })
  .catch(error => {
    console.error("Error fetching data:", error); // Handle errors
  });


	Key Differences Between Fetch API and Axios
	•	Axios automatically handles JSON parsing, whereas with the Fetch API, you need to manually call response.json().
	•	Axios has a simpler syntax and handles many HTTP-related features internally (e.g., request creation, response parsing).
	
	•	Conclusion
	•	External services, through APIs, allow your application to interact with other systems, retrieve data, and add features.
	•	Both the Fetch API and Axios library allow you to retrieve data from third-party services, but Axios offers additional features and is often simpler to use for HTTP requests.

Implementing Forms in React:

	1.	Purpose of Forms:
	•	Allow users to interact with data on a web page.
	•	Common uses include user registration, surveys, and order placement.
	•	Form components are the areas where users provide input (fields like text boxes, drop-down menus, etc.).

	2.	Form Handling in React:
	•	React handles form input and state on the client side.
	•	State is temporarily stored using component state.
	•	The setState method updates state, and data is not directly submitted to the server.

	3.	Form Components and Submission Logic:
	•	HTML provides built-in form capabilities like input, textarea, and select elements.
	•	Forms need submission logic (e.g., validating a password on clicking the Submit button) to control user input acceptance.
	•	Form validation often includes rules like password re-entry and minimum length requirements.

	4.	Key Form Management Tasks:
	•	Capturing input.
	•	Managing and updating form state.
	•	Validating input values.
	•	Displaying error messages for incorrect input.

	5.	Controlled vs. Uncontrolled Components:
	•	Uncontrolled Components:
	•	React places values on the page; the browser manages state.
	•	Inputs are stored in the DOM node; you access them using refs.
	•	Less code to write but offers less control.
	•	No need for event handlers when state changes.
	•	Controlled Components:
	•	React state manages form data explicitly.
	•	You control state changes and how data updates (using event handlers).
	•	Data is stored and returned using component state (e.g., using onChange events).
	•	Offers more control over the data.
	•	Requires writing functions to handle input changes.

	6.	Example Controlled Component:
	•	A registration form using useState to track state (e.g., email).
	•	Input elements require value and onChange attributes.
	•	Data updates on user interactions (e.g., typing).
	•	The setState method saves and updates input values.
	7.	React Hook Form Library:
	•	Simplifies state management and validation for React forms.
	•	Reduces the amount of code needed for form handling.
	•	Optimizes performance by minimizing unnecessary re-rendering.
	•	Installation: npm install react-hook-form.
	8.	Summary Points:
	•	Forms allow interaction with data.
	•	Form handling involves managing input fields, submission logic, and validation.
	•	Controlled components offer more control by managing data state explicitly, while uncontrolled components rely on the DOM.
	•	React Hook Form helps improve performance and reduce form-handling code complexity.

Introduction to Redux

	•	Component vs. Application States:
	•	Component state: Manages data specific to a single component.
	•	Application state: Manages data for the entire application and is accessible from any component.

	•	Purpose of Redux:
	•	Manages application state globally.
	•	Allows easy access and updating of application data from any component.

	•	When to Use Redux:
	•	Best for larger applications with numerous components.
	•	Useful when multiple components need access to shared data.
	•	Reduces complexity when passing data through deeply nested component trees.
	•	Benefits of Using Redux:
	•	Centralized state management in the Redux Store (single source of truth).
	•	Easier data access and updates across components.
	•	Predictable state changes, reducing debugging complexity.
	•	Improved code readability and maintainability.
	•	Optimized performance with selective component re-renders.
	•	Reduces need for creating new objects on state changes.
	•	Redux Usage:
	•	Primarily used with React but compatible with other frameworks like Angular, Vue, and standard JavaScript.
	•	Summary:
	•	Redux makes application state management more predictable and simplifies data sharing across components.
	•	Key advantages include reduced complexity, better performance, and streamlined code maintenance.

 Essential Redux Concepts:

	1.	Redux Overview:
	•	Redux is a centralized state management system for applications.
	•	Manages application-level states instead of individual component states.
	•	Component properties should be treated as immutable; new state objects are created instead of modifying existing ones.

	2.	Core Redux Concepts:
	•	Action: Represents a need for a state update. It describes what needs to be done but not how to do it.
	•	Store: Holds all application states in a centralized location.
	•	Reducer: Defines how state should change based on an action.

	3.	Redux Architecture Principles:
	•	Centralized state management allows for predictable state transitions.
	•	State changes are explicit through actions, making code easier to track and debug.

	4.	Redux Workflow Example:
	•	E-commerce Cart Scenario:
	•	User adds items to the cart by clicking “add to cart.”
	•	This triggers an action creator function, such as addItem().
	•	The function creates and returns an action object.
	•	This action object is sent to the store using a dispatch function.
	•	The store holds all application states, including cart data (e.g., total items).
	•	Reducers handle how the state is modified based on actions, ensuring state updates are predictable and immutable.

	5.	Key Terms and Functions:
	•	Dispatching an Action: The process of sending an action object to the store.
	•	Action Creator Function: A function that creates and returns an action object.
	•	State Tree: The data structure (JavaScript object) used by the store to hold all application states and manage properties.
	•	Type and Payload: Properties of the action object:
	•	Type: Identifies which reducer should handle the action.
	•	Payload: Contains additional data for the state update (e.g., the number of items to add to a cart).
	•	Reducer Function: A pure function that takes the current state and an action object, then returns a new state. It does not cause side effects.

	6.	Benefits of Redux Architecture:
	•	Predictable state management through explicit state changes.
	•	Separation of action descriptions and state modification logic simplifies code readability and maintenance.
	•	Easier debugging due to predictable state transitions.

	7.	Summary Points:
	•	Actions describe what needs to be performed.
	•	The store maintains all current states.
	•	Reducers dictate how the store’s state should change.
	•	Dispatching involves using action creators to send actions to the store.
	•	Redux architecture’s explicit and predictable state changes simplify debugging and maintenance.

Asynchronous Operations with Redux:

	1.	Synchronous vs. Asynchronous Operations:
	•	Synchronous Operations:
	•	Each operation must complete before the next begins (blocking).
	•	Example: One function execution blocks others from starting until it finishes.
	•	Asynchronous Operations:
	•	Multiple operations can run in parallel.
	•	Useful for tasks like network requests, heavy computations, or file loading.
	•	Keeps the user interface responsive while background tasks complete.
	2.	Challenges with Asynchronous Operations in Redux:
	•	Redux Architecture Needs Synchronous Behavior:
	•	State changes in Redux flow through actions, stores, and reducers synchronously.
	•	Example sequence: Action creator → Action object → Dispatch to store → Reducer updates state.
	•	Complications from Async Behavior:
	•	Blocking behavior during data fetching from servers can frustrate users.
	•	Handling state changes in real-time interactions requires managing async behavior carefully (e.g., user updating a cart before the action completes).
	3.	Using Middleware to Handle Async in Redux:
	•	Middleware Purpose:
	•	Middleware interacts with asynchronous data to maintain Redux’s synchronous state changes.
	•	It delays or controls async processes, ensuring Redux reducers continue processing actions when ready.
	4.	Thunk Middleware:
	•	How it Works:
	•	Action creators return functions (instead of objects) using Thunk.
	•	These functions interact with the Redux store and handle async operations, such as API calls.
	•	Pros:
	•	Easy to use and suitable for simple applications.
	•	Good starting point for managing async behavior.
	•	Cons:
	•	Does not scale well for large applications.
	•	Requires careful handling of concurrency issues.
	5.	Saga Middleware:
	•	How it Works:
	•	Uses ES6 generator functions called Sagas for async logic handling.
	•	Allows multitasking within Redux by pausing and resuming operations as needed.
	•	Provides advanced capabilities, including task cancellation, parallel processing, and flow control.
	•	Pros:
	•	Scales well for complex applications.
	•	Simplifies testing and debugging with features like pure functions and time travel.
	•	Flexible and powerful for managing complex async scenarios.
	•	Cons:
	•	More complex to learn compared to Thunk.
	•	Requires a solid understanding of generator functions.
	6.	Comparing Thunk and Saga:
	•	Thunk:
	•	Easy to understand, quick to implement.
	•	Limited scalability for large applications.
	•	Suitable for simple async logic.
	•	Saga:
	•	More robust and scalable.
	•	Complex to learn and use.
	•	Ideal for managing sophisticated async flows.
	7.	Summary Points:
	•	Synchronous Behavior: Blocks other operations until completion.
	•	Asynchronous Behavior: Runs operations in parallel, keeping applications responsive.
	•	Redux & Async Handling: Requires middleware like Thunk and Saga for async operations.
	•	Thunk: Action creators return functions, best for simple cases, and lightweight applications.
	•	Saga: Uses generator functions for complex async tasks, highly scalable, but more difficult to learn.

By understanding the differences between Thunk and Saga, you can choose the right middleware for your application’s async needs, ensuring a balance between simplicity and scalability.

 Binding Redux and Data Flow in Redux:

	1.	State Changes in React Applications:
	•	State Management: React state holds component properties and triggers re-rendering of the DOM when changed.
	•	Challenges: Managing state becomes complex as applications grow, leading to complicated code due to prop drilling between components.

	2.	Role of Redux in State Management:
	•	Centralized State Management: Redux manages state at the application level rather than the component level.
	•	Not Limited to React: Redux is commonly used with ReactJS but can work with other frameworks like Angular.
	•	Structure:
	•	Single Store: Holds the entire state of the application as a state tree.
	•	Root Reducer: Handles state updates, and in complex apps, it splits into smaller reducers.

	3.	Core Redux Elements for State Management:
	•	Store:
	•	Central repository for application state.
	•	Represents the state tree.
	•	Actions:
	•	Simple objects that describe state changes.
	•	Contains a type property (identifies the action) and an optional payload (data needed for the action).
	•	Sent by components to the store to indicate changes.
	•	Reducer:
	•	Pure functions that take the previous state and an action, returning a new state.
	•	The state is immutable; reducers create a new state object with modifications.
	•	Subscription:
	•	Components are notified whenever there is an update in the store’s state.

	4.	Unidirectional Data Flow in Redux:
	•	One-Way Data Flow Process:
	•	User Interaction: Starts at the component level (UI interaction).
	•	Action Dispatching: Action creators dispatch an action based on the interaction.
	•	Reducer Processing: The root reducer and any smaller reducers handle the action by generating a new state if applicable.
	•	Component Update: The store informs the component of the new state, which re-renders with updated data.
	•	Key Point: State changes are always managed through actions and reducers, ensuring predictability and immutability.

	5.	Benefits of One-Way Data Flow:
	•	Simpler State Management: Easier to track data changes and state transitions.
	•	Performance Improvements: Unlike two-way data binding (used by frameworks like Angular and Ember), one-way flow avoids performance bottlenecks by controlling data changes predictably.
	•	Reusability and Maintainability: Components, actions, and reducers can be reused and more easily maintained.

	6.	Comparison to Two-Way Binding:
	•	Two-Way Binding (Older Method):
	•	Directly changes state based on UI updates.
	•	Can lead to performance issues and complex data flow management.
	•	One-Way Binding (Redux Approach):
	•	Separates UI interactions from state changes, reducing complexity and improving maintainability.

	7.	Usage in React Native:
	•	Cross-Platform Capabilities: Redux’s state management approach can be extended to React Native for building mobile apps.
	•	Adaptation: Presentational components change to use iOS or Android-specific view components instead of HTML, but actions, reducers, and containers remain consistent.

	8.	Summary Points:
	•	React re-renders the DOM when a component state changes.
	•	Redux elements include Store, Actions, Reducer, and Subscription, which together simplify state management.
	•	Data flow in Redux is unidirectional, making state changes predictable and manageable.
	•	One-way data flow is more scalable and easier to manage than two-way binding used in older frameworks.

By leveraging Redux’s unidirectional data flow and centralized state management, developers can maintain complex applications more efficiently, track changes predictably, and simplify debugging and component reusability.

Redux Toolkit:

	1.	Definition of Redux Toolkit (RTK):
	•	RTK is an official package provided by the Redux team.
	•	Designed to simplify Redux development, reduce boilerplate code, and improve efficiency.

	2.	Utilities in Redux Toolkit:
	•	configureStore Function:
	•	Combines multiple Redux setup tasks into one function call.
	•	Includes commonly used middleware such as Redux Thunk for asynchronous actions.
	•	Enables Redux DevTools Extension for debugging.
	•	createSlice Function:
	•	Defines slice reducers that automatically handle immutable state updates.
	•	Makes it easier to write reducer logic without mutating state directly.

	3.	Benefits of Using Redux Toolkit:
	•	Reduces the boilerplate code typically associated with Redux.
	•	Leads to cleaner, more concise, and easier-to-maintain codebases.
	•	Especially useful for large applications with complex state management.

	4.	Setting Up Redux Toolkit in React:
	•	Install Redux Toolkit and React Redux using npm or yarn.
	•	Core components include at least one slice file and one store file.

	5.	Redux Toolkit Architecture:
	•	Slices:
	•	Represent pieces of application state and the logic to update them.
	•	Defined using createSlice function.
	•	Components of a slice include:
	•	Reducer: Function that receives the current state and an action, then returns a new state.
	•	Action Creators: Functions that create actions for dispatching to the store.
	•	Initial State: Defines the initial value of the state slice.
	•	Store:
	•	Single JavaScript object holding the application’s complete state tree (source of truth).
	•	Created using configureStore with reducer functions passed as an argument.
	•	Functions:
	•	getState: Access the current state.
	•	dispatch: Trigger state updates via actions.
	•	subscribe: Register listeners for state changes.

	6.	Relationship Between a Slice and the Store:
	•	Slices define individual parts of the application state and logic for updates.
	•	The store combines all slices into the complete state tree.
	•	Creation Process:
	•	Each slice reducer is added to the Redux store using configureStore.
	•	The combineReducers function merges all slice reducers into a single reducer.
	•	When actions are dispatched, the store delegates them to the appropriate slice reducers.

	7.	Example Application (E-commerce App):
	•	Components:
	•	App.jsx: Parent component.
	•	ProductQuantity.jsx: Increments/decrements product quantity using useDispatch and useSelector from React Redux.
	•	CartValue.jsx: Calculates and displays total bill amount based on product quantity from the Redux store.
	•	CounterSlice.jsx: Contains reducer logic and associated action creators (e.g., increment, decrement).
	•	Store.jsx: Configures the Redux store with the configureStore function, using the counterReducer from CounterSlice.
	•	Main.jsx: Entry point, wraps the App component with the Provider component from React Redux, passing in the Redux store as a prop.

	8.	Key Takeaways:
	•	RTK simplifies Redux development in React applications.
	•	The configureStore function combines setup logic, reducing boilerplate.
	•	The createSlice function defines state logic more efficiently, handling immutable updates automatically.
	•	Slices manage parts of application state, and the store combines them into the overall state tree.

Cheat Sheet Specific to Redux:

| Term                        | Description                                                                                                                |
|-----------------------------|----------------------------------------------------------------------------------------------------------------------------|
| Action creator              | A function that generates an action object with a type property and optional data (payload) to describe an event or change. |
| Actions in Redux            | Objects that carry information about what happened, used to send data from the app to the Redux store for state updates.   |
| Application state           | Represents the complete data structure or condition of the application at a given point in time.                           |
| Asynchronous or async code  | Code that allows tasks to run independently of each other, enabling operations like data fetching without blocking other tasks. |
| Axios                       | A popular library used to make HTTP requests for data fetching or sending, often used for APIs in web applications.         |
| combineReducers ()          | A function that merges multiple smaller reducer functions into a single root reducer, streamlining state management.       |
| createSlice ()              | Part of Redux Toolkit, this function helps define state slices and reducers with auto-generated action creators.           |
| configureStore ()           | A function in Redux Toolkit that simplifies the process of creating and setting up a Redux store with good defaults.       |
| Controlled component        | A form input element in React where component state controls its value, making state updates explicit through code.        |
| Custom hook                 | A user-defined function that leverages React hooks to create reusable stateful logic across components.                    |
| fetch                       | A built-in JavaScript API to make network requests, commonly used for retrieving or sending data asynchronously.           |
| Fields                      | Input areas in forms where users can enter or interact with data.                                                          |
| Forms                       | Interfaces that collect user input, enabling data interaction or submission on web pages.                                  |
| getState ()                 | A method provided by the Redux store to retrieve the current state object.                                                 |
| Hook                        | Special functions in React that let you use state and other React features without writing classes.                        |
| Payload property            | Extra data sent with an action, providing context or information needed to handle that action.                             |
| Reducers in Redux           | Pure functions that take the current state and an action, then return a new state based on that action.                    |
| Redux                       | A predictable state management library that centralizes app state, enabling consistent data flow between components.       |
| Redux store                 | A single source of truth for application state in Redux, managing state, actions, and logic.                               |
| Redux Saga                  | Middleware for handling side effects like async operations using functions (sagas) that make asynchronous code declarative.|
| Redux Thunk                 | A middleware allowing Redux actions to return functions, enabling delayed or conditional dispatch logic.                   |
| Redux Toolkit (RTK)         | An official package that simplifies and streamlines Redux development, providing utilities for common tasks.               |
| Side effects                | Operations triggered during component rendering, like fetching data, that need special handling outside main logic flow.   |
| Slice                       | A portion of Redux state managed with its own reducers and actions, created easily using Redux Toolkit.                    |
| Store in RTK                | The central state management object that combines all slices and tracks application state.                                |
| Subscription                | Mechanism in Redux that allows components to automatically receive state updates when the store changes.                   |
| Synchronous or sync code    | Code executed sequentially, where each task waits for the previous one to finish before proceeding.                        |
| Type property               | A string identifier for an action, describing what kind of change it represents.                                           |
| Uncontrolled component      | A form element managed mostly by the browser, with React only setting its initial value.                                   |
| useContext hook             | A React hook for accessing and managing shared state across deeply nested components without prop drilling.                |
| useEffect hook              | A React hook for managing side effects, such as data fetching or DOM manipulation, during component lifecycle changes.     |
| useReducer hook             | A React hook similar to Redux reducers, enabling complex state logic management within functional components.              |
| useState hook               | A React hook that lets you add state to function components, tracking values that can change over time.                    |