Fundamentals of libraries : React is a library 
What is library ? 
1. Library is a collection of prewritten code which provides us with reusable functions and code base,
With this reusable code base we can target a specific tasks or functionalities .

Framework : Angular is a framework ,
What is framework ? 
1. A framework is a comprehensive software development platform that provides the 
foundation and structure for building entire applications. 
Unlike libraries that offer specific functionalities, 
frameworks impose a particular architecture and provide tools, libraries, and 
guidelines to streamline the development process. Frameworks address broader concerns, 
including handling user requests, managing data flow, and structuring the application's overall architecture.
 Some popular examples of JavaScript frameworks include AngularJS, Ember JS, Svelte, and Vue.js.

React Notes

	•	Overview:
	•	Developed by: Meta (formerly Facebook)
	•	Purpose: To build dynamic, interactive user interfaces for web applications
	•	Type: Open-source JavaScript library
	•	Core Features:
	1.	Component-Based Architecture:
	•	Modular design with reusable components
	•	Components represent specific UI elements (e.g., header, sidebar, footer)
	•	Encapsulation of UI functionality in individual files for reusability
	2.	Declarative Syntax:
	•	Developers specify what the UI should do, rather than how it should operate
	•	Automatically updates UI based on state or data changes
	3.	Virtual DOM:
	•	React maintains a virtual copy of the DOM
	•	Efficiently updates only the necessary parts of the real DOM, boosting performance
	4.	One-Way Data Binding:
	•	Unidirectional data flow from parent to child components
	•	Simplifies data management, reducing bugs due to state inconsistencies
	5.	JavaScript XML (JSX):
	•	JavaScript extension that enables HTML-like syntax within JavaScript
	•	Simplifies creation and visualization of UI components
	6.	Hooks:
	•	Introduced in React 16.8
	•	Facilitates state and lifecycle management within functional components
	•	Simplifies logic, promotes code reuse, and eases management of stateful behavior
	7. Resolves problems of cross browser issues .
	8. React native : Similar to react and can help to create cross platform application.

Creating a react project  (Either one of them )
npx create-react-app my-react-app
npm create vite@latest my-vite-app
npm install 
npm run dev

Difference between both : 
Here’s a quick comparison between Vite and Create React App (CRA) for interview prep:

Vite vs. Create React App (CRA)

1. Build Speed

	•	Vite: Faster builds, near-instant dev server, fast HMR (Hot Module Replacement).
	•	CRA: Slower initial build and reload times, especially in large projects.
	Unlike CRA, which uses Webpack, Vite uses Rollup for bundling, resulting in faster build times and 
	improved performance, especially for larger projects.

Vite also supports various modern JavaScript features out of the box, such as TypeScript, JSX, and CSS preprocessors, without additional configuration.

2. Configuration

	•	Vite: Flexible, easy to customize with plugins, no “eject” needed.
	•	CRA: Zero-config but restrictive; must “eject” to access deeper configs.

3. Developer Experience

	•	Vite: Smooth, fast HMR, supports modern JavaScript features.
	•	CRA: Reliable but can be slow on reloads in larger projects.

4. Ecosystem

	•	Vite: Growing rapidly, multi-framework support (React, Vue, Svelte).
	•	CRA: Established, extensive community, React-focused.

5. Best For

	•	Vite: Larger or modern React projects needing speed and scalability.
	•	CRA: Small/medium projects, beginners needing simplicity.

Summary:

	•	Vite is better for performance, flexibility, and modern development.
	•	CRA is good for straightforward, smaller apps without heavy customization needs.

Folder Structure Notes

	•	public directory
	•	Contains static assets (e.g., HTML files, images, fonts).
	•	index.html: Entry point for the React app.
	•	src directory
	•	Holds the source code for the React app.
Key Files in src:
	•	main.jsx: Entry point file that renders the root component into the HTML in the public directory.
	•	App.jsx: Root component containing the main UI logic and other components.
	•	App.css: Styles specific to App.jsx.
	•	index.css: Global styles for the application.
	•	Other Files
	•	package.json: Holds project metadata, dependencies, and scripts for running, building, and testing the app.

This structure provides a boilerplate setup for React projects, with organized folders for assets, core app files, and configuration.

ES6 : EcmaScript 6

Introduction to ES6 (ECMAScript 6)

	1.	ECMAScript Overview
	•	ECMAScript (ES) is a standard for JavaScript created by the ECMA standards organization.
	•	ES6, released in 2015, introduced major updates.
	•	Newer versions of ES are named by release year; the latest is ECMAScript 2020.
	•	“ES.Next” refers to the upcoming ECMAScript version.
	2.	Key ES6 Features
	•	let and const: Alternatives to var with restricted scope.
	•	let is block-scoped, restricting variable usage to the block it was defined in.
	•	const defines constants whose values cannot be reassigned.
	•	Arrow Functions: A shorter syntax for writing functions, offering cleaner, concise code.
	•	Arrow functions can omit curly braces and the return keyword for single-line expressions.
	•	Commonly used in callbacks.
	•	Promises: A way to handle asynchronous operations.
	•	Promise states: pending, fulfilled, and rejected.
	•	resolve and reject are parameters used to handle the completion status.
	•	Class: Introduced object-oriented programming features.
	•	Built on JavaScript prototypes, enabling inheritance and encapsulation.
	•	Classes use a constructor for initializing new objects.
	•	this keyword refers to the current instance, and new creates new instances.
	•	Inheritance: Classes can inherit properties/methods from other classes (superclass/subclass).
	•	super calls the superclass constructor in subclasses.
	3.	Usage in JavaScript
	•	ES6 features are compatible with frameworks like React.
	•	Enhanced syntax and tools in ES6 facilitate code organization, readability, and scalability.

	JSX Overview

	1.	Definition
	•	JSX stands for JavaScript Syntax Extension, also called JavaScript XML.
	•	It combines HTML-like syntax with JavaScript expressions, making UI building more intuitive.
	2.	Syntax and Usage
	•	JSX syntax resembles XML/HTML, with elements in angle brackets (< >), showing UI structure.
	•	JSX is used to create React elements, rendered into the DOM by React.
	•	Browsers don’t recognize JSX directly; it must be compiled with Babel to convert it to standard JavaScript objects.
	3.	Compilation with Babel
	•	Babel translates JSX into JavaScript, making it readable for JavaScript engines.
	•	The create-react-app command can handle JSX compilation automatically.
	4.	Advantages of JSX
	•	Readability: Easier to understand, especially for those familiar with HTML.
	•	Error Detection: Compilation catches errors early.
	•	Code Simplification: Keeps code elegant and organized with inline styling options.
	•	Performance: Optimized for faster execution during translation.
	•	Security: Automatically sanitizes output to prevent embedded scripts from executing.
	5.	JSX vs. JavaScript Function Calls
	•	JSX syntax is cleaner, closer to HTML, and easier to read compared to equivalent JavaScript function calls.
	•	Regular JavaScript function calls for the same purpose are harder to read and maintain.
	6.	Summary
	•	JSX reads like HTML but allows JavaScript expressions within it.
	•	Benefits of JSX include enhanced readability, error handling, performance optimization, and security.

	Notes: Introduction to Components in React

Overview of React Components:

	1.	Definition: Modular chunks of code used to build React applications.
	2.	Purpose: Simplify complex UIs by dividing them into manageable, reusable pieces.
	3.	Rendering: Components are merged to form the main UI the user sees.

Features of React Components:

	•	Break down UI into separate, independent elements.
	•	Accept optional input and return a React object for rendering.
	•	Can manage UI updates through “state changes.”

Component Structure in React:

	1.	Properties (Props):
	•	Store and pass data from parent to child components.
	2.	Events:
	•	Manage the DOM based on user interaction.
	3.	States:
	•	Track and manage UI updates within the component.

Types of React Components:

	1.	Functional Components:
	•	Defined as JavaScript functions, taking arguments and returning JSX.
	•	Initially stateless but now can manage state using hooks (introduced in React 16.8).
	•	Preferred for simplicity and ease of testing.
	•	Example:

function DemoComponent() {
  return <h1>Welcome Message</h1>;
}


	2.	Class Components:
	•	Built using ES6 classes, allowing data sharing between class components.
	•	Utilize React-specific functions: state, props, and lifecycle methods.
	•	Complex and less preferred post-React 16.8 due to the availability of hooks.
	3.	Higher-Order Components (HOC):
	•	Allow reuse of component logic by taking a component as input and returning a new component with additional features.

Key Points Recap:

	•	React components modularize the UI into reusable parts, managing events, rendering, and state.
	•	Three component types: functional, class, and higher-order

Working with Function Components, Props, and Event Handling in React

Key Concepts:

	•	Props in Function Components:
	•	Properties in function components are called props.
	•	Purpose: Props pass data from a parent component to its child, enabling data flow and customization of child components.
	•	Nature: Props are immutable—data within them is read-only in the child component and cannot be modified.
	•	Basic Usage of Props:
	•	Props work similarly to objects, holding attributes for a component.
	•	Example:
	•	In a component App, data is passed as a prop (e.g., name="John") to the child component EmployeeData.
	•	In EmployeeData, props are accessed using props.name.
	•	Props can also be dynamically passed with curly braces {} for variables (e.g., employee_id).
	•	Default Props:
	•	Default values can be defined for props, providing fallback values if the parent component does not pass them.
	•	Example: EmployeeData has a default value of "Human Resources" for the dept_name prop if not explicitly provided.
	•	Principles of Props:
	•	Reusability: Props allow variations of the same component without duplicating code.
	•	Unidirectional Data Flow: Data flows in one direction, making the app structure predictable and error tracing easier.
	•	Customization: Components can adapt their behavior and appearance based on prop values.
	•	Composition: Props help in composing complex UIs from simpler components through organized data flow and interaction.

Event Handling with Props:

	•	Example with useState Hook and Event:
	•	Props can be used alongside event handling to control component behavior dynamically.
	•	useState Hook: Manages the showIncrease state to track whether salary increase information should display.
	•	onClick Event:
	•	Triggers an arrow function to toggle showIncrease state.
	•	Conditional rendering is achieved using &&, so when showIncrease is true, the salary increase value is shown.
	•	UI Changes on Event:
	•	When the user clicks a button, it updates the showIncrease state and displays additional information accordingly.

Summary Points:

	•	Props store component attributes and enable data flow from parent to child.
	•	Props principles include reusability, unidirectional data flow, customization, and composition.
	•	Using useState with event handlers enables responsive and interactive UI updates.

React Component Composition

	•	Purpose:
	•	Component composition combines small, reusable components to build complex UIs, enhancing modularity and maintainability.
	•	Principles of Component Composition:
	•	Abstraction: Encapsulate UI features into reusable components, breaking down complex UIs into manageable chunks.
	•	Reusability: Avoid code duplication by reusing components across different parts of the application.
	•	Hierarchy: Arrange components in a parent-child structure for organized, modular design.
	•	Props and Children: Pass data from parent to child components; child components inherit data or other components via props.
	•	Higher-Order Components (HOCs): Functions that accept components as input or return enhanced components with added functionality (e.g., state or logic).
	•	Example: Blog Post for Novels:
	•	Individual Components:
	•	Title, Author, Type, Description: Each component encapsulates a specific feature and follows a consistent structure:
	•	Import React, define function, format content, and export the component.
	•	Higher-Order Component (NovelBlog):
	•	Combines individual components to create a full blog post structure.
	•	Imports and arranges components (Title, Author, Type, Description) with styling.
	•	Main Application Component:
	•	Imports and composes the NovelBlog component, supplying data for title, author, description, and type.
	•	Summary:
	•	Use component composition to combine smaller, reusable components for complex UIs.
	•	Key principles: abstraction, reusability, hierarchy, props and children, HOCs.

State Management in Functional Components (React)

Introduction to State Management

	•	State management controls data changes within a React component.
	•	Previously, React couldn’t manage state in function components until hooks were introduced.
	•	Now, function components handle local state via the useState hook, enabling reusable logic without altering the component hierarchy.

useState Hook Overview

	•	useState allows state management in functional components.
	•	Returns an array with:
	•	A state variable for the current state.
	•	A function to update this state variable.
	•	Syntax:

const [stateName, setStateName] = useState(initialState);

	•	stateName: holds the current state value.
	•	setStateName: function to update the stateName.

Example: State Management with useState

	1.	Basic Setup:
	•	Create a component StateManagement using useState for the name state.
	•	Initialize name to “John” and update to “John Doe” upon button click.
	2.	Rendering the Component:
	•	Displays an <h1> title and a paragraph with the current name state.
	•	Includes a button with an onClick event to trigger setName("John Doe"), updating the name.

Example: Toggle Component with useState

	1.	ToggleMessage Component:
	•	Manages visibility of a message using isVisible state.
	•	Toggle button changes visibility by setting isVisible to !isVisible.
	2.	Rendering Toggle:
	•	Shows button text as “Hide message” if isVisible is true; otherwise, “Show message.”
	•	Conditionally displays a message based on isVisible’s value.

Summary

	•	State management helps manage and reflect dynamic data within components.
	•	useState provides a clean way to handle state in functional components.
	•	Key uses include making components interactive and managing conditional rendering.

Function Component Lifecycle in React


	•	Functional components are the core of React UI development.
	•	Although lacking traditional lifecycle methods (as in class components), hooks (e.g., useState, useEffect) allow similar lifecycle management.

Lifecycle Phases of Functional Components

	1.	Mounting Phase
	•	React initializes and prepares the component for rendering.
	•	Key steps:
	•	Initialization: Function body runs, setting up the component structure.
	•	State Initialization: useState sets up state variables (e.g., count initialized to 0).
	•	Side Effects: useEffect with an empty dependency array runs side effects (e.g., data fetching, DOM manipulation) once after the initial render.
	•	Example: useEffect fetches data on mount from an API and sets it in the component’s state.
	2.	Updating Phase
	•	React re-invokes the function component when state or props change, allowing UI updates.
	•	React re-evaluates JSX to determine new UI.
	•	Example: In myComponent, count is incremented on button click, triggering a re-render with updated UI.
	3.	Unmounting Phase
	•	React cleans up resources (e.g., event listeners, timers) when the component is removed from the DOM.
	•	Example: useEffect sets up an interval timer; a cleanup function clears it on unmount to prevent memory leaks.
	4.	Error Handling Phase
	•	Errors during rendering or lifecycle methods in child components are caught by error boundaries.
	•	Error boundaries display fallback UI, isolating the error without affecting the rest of the application.

Summary

	•	React’s lifecycle for function components includes:
	•	Mounting: Sets initial state, runs side effects.
	•	Updating: Handles state/prop changes, updates UI.
	•	Unmounting: Cleans up resources to prevent memory leaks.
	•	Error Handling: Uses error boundaries for graceful error management.

Testing React Components

	1.	Purpose of Testing
	•	Testing reviews code line-by-line to verify correct execution.
	•	Ensures application runs smoothly without errors.
	•	Advantages:
	•	Prevents regression (reoccurrence of bugs).
	•	Allows developers to focus on current tasks.
	•	Enables modular application construction.
	•	Reduces the need for manual verification.
	•	Disadvantages:
	•	Involves writing, debugging, and maintaining additional code.
	•	Non-critical test failures might impact CI processes.

	2.	Types of Testing in React
	•	Unit Testing:
	•	Tests isolated parts/components.
	•	Uses shallow rendering.
	•	Example: Rendering a component with default properties.
	•	End-to-End Testing:
	•	Tests entire application flows in a simulated browser environment.
	•	No UI is required during tests.
	•	Example: Testing an authentication flow.

	3.	Testing Workflow (Arrange-Act-Assert)
	•	Arrange: Set up component properties.
	•	Act: Render the component, trigger user actions.
	•	Assert: Verify outcomes and side effects on the component.

	4.	Considerations When Choosing Testing Tools
	•	Speed vs. Environment: Some tools prioritize speed but lack precise browser behavior, while others use real browser environments with slower feedback loops.
	•	Mocking: Important to decide which parts to mock in unit vs. integration tests.

	5.	Testing Libraries in the React Ecosystem
	•	Mocha, Chai, Sinon: Used with Node.js applications for tests.
	•	Mocha: Test runner.
	•	Chai: Assertion library.
	•	Sinon: Provides mocks, stubs, and spies.
	•	Jest: Comprehensive testing library by Facebook.
	•	Test runner, assertion library, mocks, and spies.
	•	Features:
	•	jsdom: Access DOM for component testing.
	•	Snapshot Testing: Verifies component rendering results.
	•	CLI for test execution.
	•	React Testing Library:
	•	Utility functions built on react-dom and react-dom/test-utils.
	•	Encourages tests that align with end-user interactions.
	•	Replaces Enzyme for testing React components.
	•	Accessible querying for DOM elements, facilitating label- and text-based querying.
	•	Encourages accessibility and emulates end-user component usage.
	
	6.	Testing Best Practices
	•	Render components virtually using render() from React Testing Library.
	•	Access rendered HTML through screen for assertions.
	•	Aim for tests that emulate actual user interactions to increase confidence.


